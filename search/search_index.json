{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BitBuffer is a bit stream module implemented in pure Lua. Its purpose is to provide an easy way to write and read binary data down to the bit level. It first found life as a replacement for a module that performed rather poorly, and was primarily meant for use on Roblox. However, no Roblox specific API is used in the main file or tests of the module. The module was written and tested using Lua 5.2, though any version of Lua that has a bit module should be able to run this module with a few modifications. It will probably perform best with LuaJIT, as Roblox's Lua VM is extremely fast compared to PUC-Rio and this module makes use of some specific optimizations (ipairs, as an example, is faster than a numeric for in Roblox). Why? \u00b6 Numbers take up a lot of space. Take the number 24930 . When written out, it's 5 bytes. That's not an awful lot, but if you had to save hundreds of thousands of numbers of a similiar size, that's a lot of space spent on numbers alone. When written with this BitBuffer though, 24930 only takes up 2 bytes and becomes ab . Interested how? The number 24930 is 110000101100010 in binary, which is 15 bits long. Padding it to be exactly 16 bits (2 bytes evenly), it becomes 110000101100010 . That can be split into 01100001 and 01100010 , which are equivalent to a and b respectively. Thus, ab is the binary equivalent to 24930 . Obviously, the two bytes taken up by ab is less than the 5 bytes taken up by 24930 . This difference gets a lot more dramatic the bigger the number: 1633837924 is 10 bytes to write out but in binary is abcd , and 107075202213222 is 15 bytes but turns into abcdef . That's a difference of 9 bytes per number! Support \u00b6 By default, the BitBuffer only supports basic data types (specifically bits, integers, floats, and strings) and some common variants of them. Custom structs (Vectors, coordinates, etc.) can be added rather easily by modifying the module however. An example of this is found under Customization . The module also obviously supports importing and exporting data to and from the stream. The constructor takes a string, which it will convert to a stream, and a buffer object has some functions to easily export the data inside. These are documented in Main Functions . Limitations \u00b6 A limit for the width of all numbers is hardcoded to be 64-bits. However, as Lua numbers are doubles, the maximum precision for them is actually 53 bits. If you need to store numbers at that size, you should consider alternatives regardless of whether you use the BitBuffer. Technical details \u00b6 Data written with the BitBuffer is big-endian. It follows the IEEE-754 format for floating points. Signed integers are stored using two's complements, as you would expect. By default, strings are written and read by prefixing the length as an unsigned 24-bit integer. There are a variety of tests that can be run in the tests folder to verify the functionality of the module. There are convenient scripts to run them in the repository.","title":"Home"},{"location":"#why","text":"Numbers take up a lot of space. Take the number 24930 . When written out, it's 5 bytes. That's not an awful lot, but if you had to save hundreds of thousands of numbers of a similiar size, that's a lot of space spent on numbers alone. When written with this BitBuffer though, 24930 only takes up 2 bytes and becomes ab . Interested how? The number 24930 is 110000101100010 in binary, which is 15 bits long. Padding it to be exactly 16 bits (2 bytes evenly), it becomes 110000101100010 . That can be split into 01100001 and 01100010 , which are equivalent to a and b respectively. Thus, ab is the binary equivalent to 24930 . Obviously, the two bytes taken up by ab is less than the 5 bytes taken up by 24930 . This difference gets a lot more dramatic the bigger the number: 1633837924 is 10 bytes to write out but in binary is abcd , and 107075202213222 is 15 bytes but turns into abcdef . That's a difference of 9 bytes per number!","title":"Why?"},{"location":"#support","text":"By default, the BitBuffer only supports basic data types (specifically bits, integers, floats, and strings) and some common variants of them. Custom structs (Vectors, coordinates, etc.) can be added rather easily by modifying the module however. An example of this is found under Customization . The module also obviously supports importing and exporting data to and from the stream. The constructor takes a string, which it will convert to a stream, and a buffer object has some functions to easily export the data inside. These are documented in Main Functions .","title":"Support"},{"location":"#limitations","text":"A limit for the width of all numbers is hardcoded to be 64-bits. However, as Lua numbers are doubles, the maximum precision for them is actually 53 bits. If you need to store numbers at that size, you should consider alternatives regardless of whether you use the BitBuffer.","title":"Limitations"},{"location":"#technical-details","text":"Data written with the BitBuffer is big-endian. It follows the IEEE-754 format for floating points. Signed integers are stored using two's complements, as you would expect. By default, strings are written and read by prefixing the length as an unsigned 24-bit integer. There are a variety of tests that can be run in the tests folder to verify the functionality of the module. There are convenient scripts to run them in the repository.","title":"Technical details"},{"location":"api-base/","text":"This page covers all of the abstract functions of the BitBuffer. These functions allow for writing arbitrarily sized numbers and bits, and shouldn't be used for most projects. For the main functions, including the constructor and export functions, see Main Functions . Functions that are specific to the Roblox version of the BitBuffer are documented in Roblox Functions . Potential Performance Issue Although these functions allow for reading and writing arbitrarily sized numbers, it can cause performance problems for subsequent function calls because of the math involved unless the bits involved are clean multiples of 8. As an example, if writeUnsigned(12, 0) was called, every subsequent write function call will be slower until the total length of the BitBuffer is a multiple of 8. The same is true of read functions -- readUnsigned(12) causes performance issues for read functions until the total bits read are a multiple of 8. Write functions \u00b6 writeBits \u00b6 BitBuffer.writeBits(...: integer) -> nil Writes an arbitrary number of bits to the BitBuffer. The arguments MUST all be 0 or 1. writeByte \u00b6 BitBuffer.writeByte(n: integer) -> nil Writes a byte to the BitBuffer. writeUnsigned \u00b6 BitBuffer.writeUnsigned(width: integer, n: integer) -> nil Writes an arbitrary width unsigned integer to the BitBuffer.The width MUST be in the range [1, 64] writeSigned \u00b6 BitBuffer.writeSigned(width: integer, n: integer) -> nil Writes an arbitrary width signed integer to the BitBuffer. The width MUST be in the range [2, 63] writeFloat \u00b6 Floating point numbers are complicated! Try reading the source to learn more about this function. BitBuffer.writeFloat(expWidth: integer, mantWidth: integer, n: number) -> nil Writes a floating point number with an arbitrarily long exponent and an arbitrarily long mantissa to the BitBuffer. expWidth is the length of the exponent and mantWidth is the length of the mantissa. Both expWidth and mantWidth MUST be in the range [1, 64]. Read functions \u00b6 readBits \u00b6 BitBuffer.readBits(n: integer) -> Array<integer> Reads n bits from the BitBuffer and returns them in an array of 1s and 0s. readByte \u00b6 BitBuffer.readByte() -> integer Reads a byte from the BitBuffer and returns it. readUnsigned \u00b6 BitBuffer.readUnsigned(width: integer) -> integer Reads an arbitrary width unsigned integer from the BitBuffer and returns it. The width MUST be in the range [1, 64] readSigned \u00b6 BitBuffer.readSigned(width: integer) -> integer Reads an arbitrary width signed integer from the BitBuffer and returns it. The width MUST be in the range [2, 63] readFloat \u00b6 BitBuffer.readFloat(expWidth: integer, mantWidth: integer) -> number Reads a floating point number with an arbitrarily long exponent and an arbitrarily long mantissa from the BitBuffer and returns it. expWidth is the length of the exponent and mantWidth is the length of the mantissa. Both expWidth and mantWidth MUST be in the range [1, 64].","title":"Abstract Functions"},{"location":"api-base/#write-functions","text":"","title":"Write functions"},{"location":"api-base/#writebits","text":"BitBuffer.writeBits(...: integer) -> nil Writes an arbitrary number of bits to the BitBuffer. The arguments MUST all be 0 or 1.","title":"writeBits"},{"location":"api-base/#writebyte","text":"BitBuffer.writeByte(n: integer) -> nil Writes a byte to the BitBuffer.","title":"writeByte"},{"location":"api-base/#writeunsigned","text":"BitBuffer.writeUnsigned(width: integer, n: integer) -> nil Writes an arbitrary width unsigned integer to the BitBuffer.The width MUST be in the range [1, 64]","title":"writeUnsigned"},{"location":"api-base/#writesigned","text":"BitBuffer.writeSigned(width: integer, n: integer) -> nil Writes an arbitrary width signed integer to the BitBuffer. The width MUST be in the range [2, 63]","title":"writeSigned"},{"location":"api-base/#writefloat","text":"Floating point numbers are complicated! Try reading the source to learn more about this function. BitBuffer.writeFloat(expWidth: integer, mantWidth: integer, n: number) -> nil Writes a floating point number with an arbitrarily long exponent and an arbitrarily long mantissa to the BitBuffer. expWidth is the length of the exponent and mantWidth is the length of the mantissa. Both expWidth and mantWidth MUST be in the range [1, 64].","title":"writeFloat"},{"location":"api-base/#read-functions","text":"","title":"Read functions"},{"location":"api-base/#readbits","text":"BitBuffer.readBits(n: integer) -> Array<integer> Reads n bits from the BitBuffer and returns them in an array of 1s and 0s.","title":"readBits"},{"location":"api-base/#readbyte","text":"BitBuffer.readByte() -> integer Reads a byte from the BitBuffer and returns it.","title":"readByte"},{"location":"api-base/#readunsigned","text":"BitBuffer.readUnsigned(width: integer) -> integer Reads an arbitrary width unsigned integer from the BitBuffer and returns it. The width MUST be in the range [1, 64]","title":"readUnsigned"},{"location":"api-base/#readsigned","text":"BitBuffer.readSigned(width: integer) -> integer Reads an arbitrary width signed integer from the BitBuffer and returns it. The width MUST be in the range [2, 63]","title":"readSigned"},{"location":"api-base/#readfloat","text":"BitBuffer.readFloat(expWidth: integer, mantWidth: integer) -> number Reads a floating point number with an arbitrarily long exponent and an arbitrarily long mantissa from the BitBuffer and returns it. expWidth is the length of the exponent and mantWidth is the length of the mantissa. Both expWidth and mantWidth MUST be in the range [1, 64].","title":"readFloat"},{"location":"api-main/","text":"This page covers all of the main functions of the BitBuffer. These include the constructor, functions to get the data out of the BitBuffer, and its main read/write functions. Abstract functions, like writeUnsigned (which allows writing an integer of arbitrary size) aren't documented on this page since they shouldn't generally see use in a normal project. However, they're still useful and are thus documented in Abstract Functions . Functions that are specific to the Roblox version of the BitBuffer are documented in Roblox Functions . Type Information This API reference provides the argument and return types for the various functions. They will hopefully be self-explanatory, but as a brief overview, the type of arguments look like this: x: number and means that x is a number . If an argument's type is followed by a ? , it means the argument is optional. The return type of a function follows a -> . Thus, BitBuffer(stream: string?) -> BitBuffer means that the function BitBuffer optionally takes a string as an argument and returns a BitBuffer. BitBuffer \u00b6 Constructor \u00b6 BitBuffer(stream: string?) -> BitBuffer Creates a new BitBuffer object and fills it with stream if it's provided. Otherwise, returns an empty BitBuffer. getPointer \u00b6 BitBuffer.getPointer() -> integer Returns where the pointer is in the stream. The pointer is the bit from which the various Read functions operate. setPointer \u00b6 BitBuffer.setPointer(n: integer) -> nil Sets where the pointer is in the stream in bits. setPointerFromEnd \u00b6 BitBuffer.setPointerFromEnd(n: integer) -> nil Sets the pointer in bits from the end of the stream. Equivalent to setPointer(getBitLength()-n) . getPointerByte \u00b6 BitBuffer.getPointerByte() -> integer Returns the byte the pointer is at in the stream. setPointerByte \u00b6 BitBuffer.setPointerByte(n: integer) -> nil Sets where the pointer is in the stream in bytes. setPointerByteFromEnd \u00b6 BitBuffer.setPointerByteFromEnd(n: integer) -> nil Sets the pointer in bytes from the end of the stream. Equivalent to setPointerByte(getLength()-n) . getLength \u00b6 BitBuffer.getLength() -> integer Returns the length of the internal buffer in bits. getByteLength \u00b6 BitBuffer.getByteLength() -> integer Returns the length of the internal buffer in bytes. isFinished \u00b6 BitBuffer.isFinished() -> boolean Returns whether or not the buffer has data left in it to read. Export functions \u00b6 The following functions are all intended to get data out of the BitBuffer in some way. dumpBinary \u00b6 BitBuffer.dumpBinary() -> string Returns a string of binary digits that represents the content of the BitBuffer. This is primarily intended for debugging or testing purposes. dumpString \u00b6 BitBuffer.dumpString() -> string Returns the raw binary content of the BitBuffer. This function is one of the main methods for getting things out of the buffer, and outputs the raw binary data. dumpBase64 \u00b6 BitBuffer.dumpBase64() -> string Returns the base64 encoded content of the BitBuffer. This function doesn't add linebreaks to the data. To write base64 data to the BitBuffer, use writeBase64 dumpHex \u00b6 BitBuffer.dumpHex() -> string Returns a string of hex characters representing the contents of the BitBuffer. exportChunk \u00b6 BitBuffer.exportChunk(chunkLength: integer) -> iterator() -> i: integer, chunk: string Returns an iterator function that can be used to get individual chunks and their position in the Buffer. local buffer = BitBuffer ( \"foo|bar|baz\" ) for position , chunk in buffer . exportChunk ( 4 ) do print ( position , chunk ) end Would output: 1 foo| 5 bar| 9 baz exportBase64Chunk \u00b6 BitBuffer.exportBase64Chunk(chunkLength: integer)- > iterator() -> chunk: string Returns an iterator function that can be used to get individual chunks of the Buffer, encoded to Base64. The chunkLength argument is the size of the Base64 output, not the size of the chunk pre-encoding. local buffer = BitBuffer ( \"foo|bar|baz\" ) for chunk in buffer . exportBase64Chunk ( 4 ) do print ( chunk ) end Would output: Zm9v fGJh cnxi YXo= exportHexChunk \u00b6 BitBuffer.exportHexChunk(chunkLength: integer)- > iterator() -> chunk: string Returns an iterator function that can be used to get individual chunks of the Buffer with their bytes in hex. The chunkLength argument is the size of the hex output, not the size of the chunk pre-encoding. local buffer = BitBuffer ( \"foo|bar|baz\" ) for chunk in buffer . exportHexChunk ( 8 ) do print ( chunk ) end Would output: 666f6f7c 6261727c 62617a crc32 \u00b6 BitBuffer.crc32() -> integer Returns the CRC-32 checksum of the BitBuffer's contents. Write functions \u00b6 The following functions are all intended to write data to the BitBuffer. With little exception, they're more efficient than calling their abstract equivalents and should be used over them. writeUInt8 \u00b6 BitBuffer.writeUInt8(n: integer) -> nil Writes the unsigned 8-bit integer n to the BitBuffer. Directly calls BitBuffer.writeByte , but included for the sake of completion. writeUInt16 \u00b6 BitBuffer.writeUInt16(n: integer) -> nil Writes the unsigned 16-bit integer n to the BitBuffer. writeUInt32 \u00b6 BitBuffer.writeUInt32(n: integer) -> nil Writes the unsigned 32-bit integer n to the BitBuffer. writeInt8 \u00b6 BitBuffer.writeUInt8(n: integer) -> nil Writes the signed 8-bit integer n to the BitBuffer. writeInt16 \u00b6 BitBuffer.writeUInt16(n: integer) -> nil Writes the signed 16-bit integer n to the BitBuffer. writeInt32 \u00b6 BitBuffer.writeUInt32(n: integer) -> nil Writes the signed 32-bit integer n to the BitBuffer. writeFloat16 \u00b6 BitBuffer.writeFloat16(n: number) -> nil Writes a half-precision (16-bit) floating point number to the BitBuffer. writeFloat32 \u00b6 BitBuffer.writeFloat32(n: number) -> nil Writes a single-precision (32-bit) floating point number to the BitBuffer. writeFloat64 \u00b6 BitBuffer.writeFloat64(n: number) -> nil Writes a double-precision (64-bit) floating point number to the BitBuffer. In most installs of Lua (including Roblox), all Lua numbers are doubles, so this should be used if the precision of a number is important. writeBase64 \u00b6 BitBuffer.writeBase64(input: string) -> nil Writes a sequence of base64 bytes to the BitBuffer, decoding them in the process. Padding is optional, and non-base64 characters will cause an error. To retrieve base64 output, use dumpBase64 . writeString \u00b6 BitBuffer.writeString(str: string) -> nil Writes a length-prefixed string to the BitBuffer. The length is written as a 24-bit unsigned integer before the bytes of the string. writeTerminatedString \u00b6 BitBuffer.writeTerminatedString(str: string) -> nil Writes a null-terminated string to the BitBuffer. For efficiency's sake, this function doesn't check to see if str contains an embedded \\0 character, so plan accordingly. writeSetLengthString \u00b6 BitBuffer.writeSetLengthString(str: string) -> nil Writes a set-length string to the BitBuffer. No information is stored about the length of the string -- readSetLengthString requires the length of the written string to read. writeField \u00b6 Potential Performance Issue Although this function allows for writing fields that aren't a multiple of 8 bits long, it can cause performance problems for subsequent writes because of the math involved. You should try to keep writeField calls to the end of the file or make sure they're multiples of 8. BitBuffer.writeField(...: any) -> nil Writes a bitfield with a bit for every argument passed. If the argument is truthy, the bit is 1 . Otherwise, it's false . The max number of arguments able to be passed to this function is 53 (see the section on limitations ). Read functions \u00b6 The following functions are all intended to read data from the BitBuffer. With little exception, they're more efficient than calling their abstract equivalents and should be used over them. readUInt8 \u00b6 BitBuffer.readUInt8() -> integer Reads an 8-bit unsigned integer from the BitBuffer and returns it. readUInt16 \u00b6 BitBuffer.readUInt16() -> integer Reads a 16-bit unsigned integer from the BitBuffer and returns it. readUInt32 \u00b6 BitBuffer.readUInt32() -> integer Reads a 32-bit unsigned integer from the BitBuffer and returns it. readInt8 \u00b6 BitBuffer.readInt8() -> integer Reads an 8-bit signed integer from the BitBuffer and returns it. readInt16 \u00b6 BitBuffer.readInt16() -> integer Reads a 16-bit signed integer from the BitBuffer and returns it. readInt32 \u00b6 BitBuffer.readInt32() -> integer Reads an 32-bit signed integer from the BitBuffer and returns it. readFloat16 \u00b6 BitBuffer.readFloat16() -> number Reads a half-precision (16-bit) floating point number from the BitBuffer and returns it. readFloat32 \u00b6 BitBuffer.readFloat32() -> number Reads a single-precision (32-bit) floating point number from the BitBuffer and returns it. readFloat64 \u00b6 BitBuffer.readFloat64() -> number Reads a double-precision (64-bit) floating point number from the BitBuffer and returns it. readString \u00b6 BitBuffer.readString() -> string Reads a length-prefixed string from the BitBuffer and returns it. readTerminatedString \u00b6 BitBuffer.readTerminatedString() -> string Reads a null-terminated string from the BitBuffer and returns it. readSetLengthString \u00b6 BitBuffer.readSetLengthString(length: integer) -> string Reads a length byte string from the BitBuffer and returns it. readField \u00b6 Potential Performance Issue Although this function allows for reading fields that aren't a multiple of 8 bits long, it can cause performance problems for subsequent reads because of the math involved. You should try to keep readField calls to the end of the file or make sure they're multiples of 8. BitBuffer.readField(n: integer) -> Array<boolean> Reads an n width bitfield from the BitBuffer and returns an array of bools that represent its bits.","title":"Main Functions"},{"location":"api-main/#bitbuffer","text":"","title":"BitBuffer"},{"location":"api-main/#constructor","text":"BitBuffer(stream: string?) -> BitBuffer Creates a new BitBuffer object and fills it with stream if it's provided. Otherwise, returns an empty BitBuffer.","title":"Constructor"},{"location":"api-main/#getpointer","text":"BitBuffer.getPointer() -> integer Returns where the pointer is in the stream. The pointer is the bit from which the various Read functions operate.","title":"getPointer"},{"location":"api-main/#setpointer","text":"BitBuffer.setPointer(n: integer) -> nil Sets where the pointer is in the stream in bits.","title":"setPointer"},{"location":"api-main/#setpointerfromend","text":"BitBuffer.setPointerFromEnd(n: integer) -> nil Sets the pointer in bits from the end of the stream. Equivalent to setPointer(getBitLength()-n) .","title":"setPointerFromEnd"},{"location":"api-main/#getpointerbyte","text":"BitBuffer.getPointerByte() -> integer Returns the byte the pointer is at in the stream.","title":"getPointerByte"},{"location":"api-main/#setpointerbyte","text":"BitBuffer.setPointerByte(n: integer) -> nil Sets where the pointer is in the stream in bytes.","title":"setPointerByte"},{"location":"api-main/#setpointerbytefromend","text":"BitBuffer.setPointerByteFromEnd(n: integer) -> nil Sets the pointer in bytes from the end of the stream. Equivalent to setPointerByte(getLength()-n) .","title":"setPointerByteFromEnd"},{"location":"api-main/#getlength","text":"BitBuffer.getLength() -> integer Returns the length of the internal buffer in bits.","title":"getLength"},{"location":"api-main/#getbytelength","text":"BitBuffer.getByteLength() -> integer Returns the length of the internal buffer in bytes.","title":"getByteLength"},{"location":"api-main/#isfinished","text":"BitBuffer.isFinished() -> boolean Returns whether or not the buffer has data left in it to read.","title":"isFinished"},{"location":"api-main/#export-functions","text":"The following functions are all intended to get data out of the BitBuffer in some way.","title":"Export functions"},{"location":"api-main/#dumpbinary","text":"BitBuffer.dumpBinary() -> string Returns a string of binary digits that represents the content of the BitBuffer. This is primarily intended for debugging or testing purposes.","title":"dumpBinary"},{"location":"api-main/#dumpstring","text":"BitBuffer.dumpString() -> string Returns the raw binary content of the BitBuffer. This function is one of the main methods for getting things out of the buffer, and outputs the raw binary data.","title":"dumpString"},{"location":"api-main/#dumpbase64","text":"BitBuffer.dumpBase64() -> string Returns the base64 encoded content of the BitBuffer. This function doesn't add linebreaks to the data. To write base64 data to the BitBuffer, use writeBase64","title":"dumpBase64"},{"location":"api-main/#dumphex","text":"BitBuffer.dumpHex() -> string Returns a string of hex characters representing the contents of the BitBuffer.","title":"dumpHex"},{"location":"api-main/#exportchunk","text":"BitBuffer.exportChunk(chunkLength: integer) -> iterator() -> i: integer, chunk: string Returns an iterator function that can be used to get individual chunks and their position in the Buffer. local buffer = BitBuffer ( \"foo|bar|baz\" ) for position , chunk in buffer . exportChunk ( 4 ) do print ( position , chunk ) end Would output: 1 foo| 5 bar| 9 baz","title":"exportChunk"},{"location":"api-main/#exportbase64chunk","text":"BitBuffer.exportBase64Chunk(chunkLength: integer)- > iterator() -> chunk: string Returns an iterator function that can be used to get individual chunks of the Buffer, encoded to Base64. The chunkLength argument is the size of the Base64 output, not the size of the chunk pre-encoding. local buffer = BitBuffer ( \"foo|bar|baz\" ) for chunk in buffer . exportBase64Chunk ( 4 ) do print ( chunk ) end Would output: Zm9v fGJh cnxi YXo=","title":"exportBase64Chunk"},{"location":"api-main/#exporthexchunk","text":"BitBuffer.exportHexChunk(chunkLength: integer)- > iterator() -> chunk: string Returns an iterator function that can be used to get individual chunks of the Buffer with their bytes in hex. The chunkLength argument is the size of the hex output, not the size of the chunk pre-encoding. local buffer = BitBuffer ( \"foo|bar|baz\" ) for chunk in buffer . exportHexChunk ( 8 ) do print ( chunk ) end Would output: 666f6f7c 6261727c 62617a","title":"exportHexChunk"},{"location":"api-main/#crc32","text":"BitBuffer.crc32() -> integer Returns the CRC-32 checksum of the BitBuffer's contents.","title":"crc32"},{"location":"api-main/#write-functions","text":"The following functions are all intended to write data to the BitBuffer. With little exception, they're more efficient than calling their abstract equivalents and should be used over them.","title":"Write functions"},{"location":"api-main/#writeuint8","text":"BitBuffer.writeUInt8(n: integer) -> nil Writes the unsigned 8-bit integer n to the BitBuffer. Directly calls BitBuffer.writeByte , but included for the sake of completion.","title":"writeUInt8"},{"location":"api-main/#writeuint16","text":"BitBuffer.writeUInt16(n: integer) -> nil Writes the unsigned 16-bit integer n to the BitBuffer.","title":"writeUInt16"},{"location":"api-main/#writeuint32","text":"BitBuffer.writeUInt32(n: integer) -> nil Writes the unsigned 32-bit integer n to the BitBuffer.","title":"writeUInt32"},{"location":"api-main/#writeint8","text":"BitBuffer.writeUInt8(n: integer) -> nil Writes the signed 8-bit integer n to the BitBuffer.","title":"writeInt8"},{"location":"api-main/#writeint16","text":"BitBuffer.writeUInt16(n: integer) -> nil Writes the signed 16-bit integer n to the BitBuffer.","title":"writeInt16"},{"location":"api-main/#writeint32","text":"BitBuffer.writeUInt32(n: integer) -> nil Writes the signed 32-bit integer n to the BitBuffer.","title":"writeInt32"},{"location":"api-main/#writefloat16","text":"BitBuffer.writeFloat16(n: number) -> nil Writes a half-precision (16-bit) floating point number to the BitBuffer.","title":"writeFloat16"},{"location":"api-main/#writefloat32","text":"BitBuffer.writeFloat32(n: number) -> nil Writes a single-precision (32-bit) floating point number to the BitBuffer.","title":"writeFloat32"},{"location":"api-main/#writefloat64","text":"BitBuffer.writeFloat64(n: number) -> nil Writes a double-precision (64-bit) floating point number to the BitBuffer. In most installs of Lua (including Roblox), all Lua numbers are doubles, so this should be used if the precision of a number is important.","title":"writeFloat64"},{"location":"api-main/#writebase64","text":"BitBuffer.writeBase64(input: string) -> nil Writes a sequence of base64 bytes to the BitBuffer, decoding them in the process. Padding is optional, and non-base64 characters will cause an error. To retrieve base64 output, use dumpBase64 .","title":"writeBase64"},{"location":"api-main/#writestring","text":"BitBuffer.writeString(str: string) -> nil Writes a length-prefixed string to the BitBuffer. The length is written as a 24-bit unsigned integer before the bytes of the string.","title":"writeString"},{"location":"api-main/#writeterminatedstring","text":"BitBuffer.writeTerminatedString(str: string) -> nil Writes a null-terminated string to the BitBuffer. For efficiency's sake, this function doesn't check to see if str contains an embedded \\0 character, so plan accordingly.","title":"writeTerminatedString"},{"location":"api-main/#writesetlengthstring","text":"BitBuffer.writeSetLengthString(str: string) -> nil Writes a set-length string to the BitBuffer. No information is stored about the length of the string -- readSetLengthString requires the length of the written string to read.","title":"writeSetLengthString"},{"location":"api-main/#writefield","text":"Potential Performance Issue Although this function allows for writing fields that aren't a multiple of 8 bits long, it can cause performance problems for subsequent writes because of the math involved. You should try to keep writeField calls to the end of the file or make sure they're multiples of 8. BitBuffer.writeField(...: any) -> nil Writes a bitfield with a bit for every argument passed. If the argument is truthy, the bit is 1 . Otherwise, it's false . The max number of arguments able to be passed to this function is 53 (see the section on limitations ).","title":"writeField"},{"location":"api-main/#read-functions","text":"The following functions are all intended to read data from the BitBuffer. With little exception, they're more efficient than calling their abstract equivalents and should be used over them.","title":"Read functions"},{"location":"api-main/#readuint8","text":"BitBuffer.readUInt8() -> integer Reads an 8-bit unsigned integer from the BitBuffer and returns it.","title":"readUInt8"},{"location":"api-main/#readuint16","text":"BitBuffer.readUInt16() -> integer Reads a 16-bit unsigned integer from the BitBuffer and returns it.","title":"readUInt16"},{"location":"api-main/#readuint32","text":"BitBuffer.readUInt32() -> integer Reads a 32-bit unsigned integer from the BitBuffer and returns it.","title":"readUInt32"},{"location":"api-main/#readint8","text":"BitBuffer.readInt8() -> integer Reads an 8-bit signed integer from the BitBuffer and returns it.","title":"readInt8"},{"location":"api-main/#readint16","text":"BitBuffer.readInt16() -> integer Reads a 16-bit signed integer from the BitBuffer and returns it.","title":"readInt16"},{"location":"api-main/#readint32","text":"BitBuffer.readInt32() -> integer Reads an 32-bit signed integer from the BitBuffer and returns it.","title":"readInt32"},{"location":"api-main/#readfloat16","text":"BitBuffer.readFloat16() -> number Reads a half-precision (16-bit) floating point number from the BitBuffer and returns it.","title":"readFloat16"},{"location":"api-main/#readfloat32","text":"BitBuffer.readFloat32() -> number Reads a single-precision (32-bit) floating point number from the BitBuffer and returns it.","title":"readFloat32"},{"location":"api-main/#readfloat64","text":"BitBuffer.readFloat64() -> number Reads a double-precision (64-bit) floating point number from the BitBuffer and returns it.","title":"readFloat64"},{"location":"api-main/#readstring","text":"BitBuffer.readString() -> string Reads a length-prefixed string from the BitBuffer and returns it.","title":"readString"},{"location":"api-main/#readterminatedstring","text":"BitBuffer.readTerminatedString() -> string Reads a null-terminated string from the BitBuffer and returns it.","title":"readTerminatedString"},{"location":"api-main/#readsetlengthstring","text":"BitBuffer.readSetLengthString(length: integer) -> string Reads a length byte string from the BitBuffer and returns it.","title":"readSetLengthString"},{"location":"api-main/#readfield","text":"Potential Performance Issue Although this function allows for reading fields that aren't a multiple of 8 bits long, it can cause performance problems for subsequent reads because of the math involved. You should try to keep readField calls to the end of the file or make sure they're multiples of 8. BitBuffer.readField(n: integer) -> Array<boolean> Reads an n width bitfield from the BitBuffer and returns an array of bools that represent its bits.","title":"readField"},{"location":"api-roblox/","text":"This page covers all of the functions specific to the Roblox version of the BitBuffer. These functions allow for reading and writing Roblox specific datatypes to and from the BitBuffer. For the main functions, including the constructor and export functions, see Main Functions . The abstract BitBuffer functions are documented in Abstract Functions . Write functions \u00b6 writeBrickColor \u00b6 BitBuffer.writeBrickColor(n: BrickColor) -> nil Writes a BrickColor to the BitBuffer as a 16-bit unsigned integer. writeColor3 \u00b6 BitBuffer.writeColor3(n: Color3) -> nil Writes a Color3 to the BitBuffer as a 24-bit integer. Colors with RGB components outside of [0, 255] are not saved properly and may throw. writeCFrame \u00b6 BitBuffer.writeCFrame(n: CFrame) -> nil Writes a CFrame to the BitBuffer. If the CFrame is axis aligned (all of its faces are aligned with an axis), it takes up 13 bytes. Otherwise, it takes up 49. writeVector3 \u00b6 BitBuffer.writeVector3(n: Vector3) -> nil Writes a Vector3 to the BitBuffer as three 32-bit floats. The written size is 12 bytes. writeVector2 \u00b6 BitBuffer.writeVector2(n: Vector2) -> nil Writes a Vector2 to the BitBuffer as two 32-bit floats. The written size is 8 bytes. writeUDim2 \u00b6 BitBuffer.writeUDim2(u2: UDim2) -> nil Writes a UDim2 to the BitBuffer as two 32-bit floats and two signed 32-bit integers. The written size is 16 bytes. writeUDim \u00b6 BitBuffer.writeUDim(u: UDim) -> nil Writes a UDim to the BitBuffer as a 32-bit float and a 32-bit signed integer. The written size is 8 bytes. writeRay \u00b6 BitBuffer.writeRay(ray: Ray) -> nil Writes a Ray to the BitBuffer as two Vector3s representing the Origin and Direction . The written size is 24 bytes. writeRect \u00b6 BitBuffer.writeRay(rect: Rect) -> nil Writes a Rect to the BitBuffer as two Vector2s representing the Min and Max . The written size is 16 bytes. writeRegion3 \u00b6 BitBuffer.writeRegion3(region: Region3) -> nil Writes a Region3 to the BitBuffer as two Vector3s representing the Min and Max . The written size is 24 bytes. Region3s do not have properties indicating their minimums and maximums, so they are determined using arithmetic. As a result, the value stores is subject to floating point errors. writeEnum \u00b6 BitBuffer.writeEnum(enum: EnumItem) -> nil Writes any EnumItem to the BitBuffer as a null-terminated string and a 16-bit unsigned integer. Due to the nature of this datatype, the written size varies. The size in bytes can be determined with #tostring(enum.EnumType) + 3 . writeNumberRange \u00b6 BitBuffer.writeNumberRange(range: NumberRange) -> nil Writes a NumberRange to the BitBuffer as two 32-bit floats. The written size is 8 bytes. writeNumberSequence \u00b6 BitBuffer.writeNumberSequence(sequence: NumberSequence) -> nil Writes a NumberSequence to the BitBuffer as an array of NumberSequenceKeypoints. Due to the nature of the datatype, the written size varies. The size in bytes can be determined with (#sequence.Keypoints*12)+4 . writeColorSequence \u00b6 BitBuffer.writeColorSequence(sequence: ColorSequence) -> nil Writes a ColorSequence to the BitBuffer as an array of ColorSequenceKeypoints. Due to the nature of the datatype, the written size varies. The size in bytes can be determined with (#sequence.Keypoints*7)+4 . Read functions \u00b6 readBrickColor \u00b6 BitBuffer.readBrickColor() -> BrickColor Reads a BrickColor from the BitBuffer and returns it. readColor3 \u00b6 BitBuffer.readColor3() -> Color3 Reads a Color3 from the BitBuffer and returns it. readCFrame \u00b6 BitBuffer.readCFrame() -> CFrame Reads a CFrame from the BitBuffer and returns it. readVector3 \u00b6 BitBuffer.readVector3() -> Vector3 Reads a Vector3 from the BitBuffer and returns it. readVector2 \u00b6 BitBuffer.readVector2() -> Vector2 Reads a Vector2 from the BitBuffer and returns it. readUDim2 \u00b6 BitBuffer.readUDim2() -> UDim2 Reads a UDim2 from the BitBuffer and returns it. readUDim \u00b6 BitBuffer.readUDim() -> UDim Reads a UDim from the BitBuffer and returns it readRay \u00b6 BitBuffer.readRay() -> Ray Reads a Ray from the BitBuffer and returns it. readRect \u00b6 BitBuffer.readRect() -> Rect Reads a Rect from the BitBuffer and returns it. readRegion3 \u00b6 BitBuffer.readRegion3() -> Region3 Reads a Region3 from the BitBuffer and returns it. Note that because of limitations with the Roblox API, the Region3 will have lost precision over what was originally written. readEnum \u00b6 BitBuffer.readEnum() -> EnumItem Reads an EnumItem from the BitBuffer and returns it. readNumberRange \u00b6 BitBuffer.readNumberRange() -> NumberRange Reads a NumberRange from the BitBuffer and returns it. readNumberSequence \u00b6 BitBuffer.readNumberSequence() -> NumberSequence Reads a NumberSequence from the BitBuffer and returns it. readColorSequence \u00b6 BitBuffer.readColorSequence() -> ColorSequence Reads a ColorSequence from the BitBuffer and returns it.","title":"Roblox Functions"},{"location":"api-roblox/#write-functions","text":"","title":"Write functions"},{"location":"api-roblox/#writebrickcolor","text":"BitBuffer.writeBrickColor(n: BrickColor) -> nil Writes a BrickColor to the BitBuffer as a 16-bit unsigned integer.","title":"writeBrickColor"},{"location":"api-roblox/#writecolor3","text":"BitBuffer.writeColor3(n: Color3) -> nil Writes a Color3 to the BitBuffer as a 24-bit integer. Colors with RGB components outside of [0, 255] are not saved properly and may throw.","title":"writeColor3"},{"location":"api-roblox/#writecframe","text":"BitBuffer.writeCFrame(n: CFrame) -> nil Writes a CFrame to the BitBuffer. If the CFrame is axis aligned (all of its faces are aligned with an axis), it takes up 13 bytes. Otherwise, it takes up 49.","title":"writeCFrame"},{"location":"api-roblox/#writevector3","text":"BitBuffer.writeVector3(n: Vector3) -> nil Writes a Vector3 to the BitBuffer as three 32-bit floats. The written size is 12 bytes.","title":"writeVector3"},{"location":"api-roblox/#writevector2","text":"BitBuffer.writeVector2(n: Vector2) -> nil Writes a Vector2 to the BitBuffer as two 32-bit floats. The written size is 8 bytes.","title":"writeVector2"},{"location":"api-roblox/#writeudim2","text":"BitBuffer.writeUDim2(u2: UDim2) -> nil Writes a UDim2 to the BitBuffer as two 32-bit floats and two signed 32-bit integers. The written size is 16 bytes.","title":"writeUDim2"},{"location":"api-roblox/#writeudim","text":"BitBuffer.writeUDim(u: UDim) -> nil Writes a UDim to the BitBuffer as a 32-bit float and a 32-bit signed integer. The written size is 8 bytes.","title":"writeUDim"},{"location":"api-roblox/#writeray","text":"BitBuffer.writeRay(ray: Ray) -> nil Writes a Ray to the BitBuffer as two Vector3s representing the Origin and Direction . The written size is 24 bytes.","title":"writeRay"},{"location":"api-roblox/#writerect","text":"BitBuffer.writeRay(rect: Rect) -> nil Writes a Rect to the BitBuffer as two Vector2s representing the Min and Max . The written size is 16 bytes.","title":"writeRect"},{"location":"api-roblox/#writeregion3","text":"BitBuffer.writeRegion3(region: Region3) -> nil Writes a Region3 to the BitBuffer as two Vector3s representing the Min and Max . The written size is 24 bytes. Region3s do not have properties indicating their minimums and maximums, so they are determined using arithmetic. As a result, the value stores is subject to floating point errors.","title":"writeRegion3"},{"location":"api-roblox/#writeenum","text":"BitBuffer.writeEnum(enum: EnumItem) -> nil Writes any EnumItem to the BitBuffer as a null-terminated string and a 16-bit unsigned integer. Due to the nature of this datatype, the written size varies. The size in bytes can be determined with #tostring(enum.EnumType) + 3 .","title":"writeEnum"},{"location":"api-roblox/#writenumberrange","text":"BitBuffer.writeNumberRange(range: NumberRange) -> nil Writes a NumberRange to the BitBuffer as two 32-bit floats. The written size is 8 bytes.","title":"writeNumberRange"},{"location":"api-roblox/#writenumbersequence","text":"BitBuffer.writeNumberSequence(sequence: NumberSequence) -> nil Writes a NumberSequence to the BitBuffer as an array of NumberSequenceKeypoints. Due to the nature of the datatype, the written size varies. The size in bytes can be determined with (#sequence.Keypoints*12)+4 .","title":"writeNumberSequence"},{"location":"api-roblox/#writecolorsequence","text":"BitBuffer.writeColorSequence(sequence: ColorSequence) -> nil Writes a ColorSequence to the BitBuffer as an array of ColorSequenceKeypoints. Due to the nature of the datatype, the written size varies. The size in bytes can be determined with (#sequence.Keypoints*7)+4 .","title":"writeColorSequence"},{"location":"api-roblox/#read-functions","text":"","title":"Read functions"},{"location":"api-roblox/#readbrickcolor","text":"BitBuffer.readBrickColor() -> BrickColor Reads a BrickColor from the BitBuffer and returns it.","title":"readBrickColor"},{"location":"api-roblox/#readcolor3","text":"BitBuffer.readColor3() -> Color3 Reads a Color3 from the BitBuffer and returns it.","title":"readColor3"},{"location":"api-roblox/#readcframe","text":"BitBuffer.readCFrame() -> CFrame Reads a CFrame from the BitBuffer and returns it.","title":"readCFrame"},{"location":"api-roblox/#readvector3","text":"BitBuffer.readVector3() -> Vector3 Reads a Vector3 from the BitBuffer and returns it.","title":"readVector3"},{"location":"api-roblox/#readvector2","text":"BitBuffer.readVector2() -> Vector2 Reads a Vector2 from the BitBuffer and returns it.","title":"readVector2"},{"location":"api-roblox/#readudim2","text":"BitBuffer.readUDim2() -> UDim2 Reads a UDim2 from the BitBuffer and returns it.","title":"readUDim2"},{"location":"api-roblox/#readudim","text":"BitBuffer.readUDim() -> UDim Reads a UDim from the BitBuffer and returns it","title":"readUDim"},{"location":"api-roblox/#readray","text":"BitBuffer.readRay() -> Ray Reads a Ray from the BitBuffer and returns it.","title":"readRay"},{"location":"api-roblox/#readrect","text":"BitBuffer.readRect() -> Rect Reads a Rect from the BitBuffer and returns it.","title":"readRect"},{"location":"api-roblox/#readregion3","text":"BitBuffer.readRegion3() -> Region3 Reads a Region3 from the BitBuffer and returns it. Note that because of limitations with the Roblox API, the Region3 will have lost precision over what was originally written.","title":"readRegion3"},{"location":"api-roblox/#readenum","text":"BitBuffer.readEnum() -> EnumItem Reads an EnumItem from the BitBuffer and returns it.","title":"readEnum"},{"location":"api-roblox/#readnumberrange","text":"BitBuffer.readNumberRange() -> NumberRange Reads a NumberRange from the BitBuffer and returns it.","title":"readNumberRange"},{"location":"api-roblox/#readnumbersequence","text":"BitBuffer.readNumberSequence() -> NumberSequence Reads a NumberSequence from the BitBuffer and returns it.","title":"readNumberSequence"},{"location":"api-roblox/#readcolorsequence","text":"BitBuffer.readColorSequence() -> ColorSequence Reads a ColorSequence from the BitBuffer and returns it.","title":"readColorSequence"},{"location":"customization/","text":"Attention Roblox users This is important information, but it's a lot less important for Roblox developers. The Roblox variant of this module already has all of the Roblox data types in it. By default, the BitBuffer doesn't have any complex datatypes in it. It only has the ability to write bits, bytes, unsigned and signed integers, floats, and strings. It also comes out of the box with a few functions to make writing standard sizes more convenient (stuff like being able to call writeUInt32(X) instead of writeUnsigned(32, X) ). For some enviroments, it might make sense to have shorthands for writing longer data pieces though. In the example , there's a table that looks like this: { x = 10.55915 , y = - 15.2222 , } If this sort of structure shows up in data quite often, it would make sense to write a seperate set of functions in the module to write and read it. Those functions can be written and inserted into the module easily and used from there. They should go after all the built-in functions (so that those functions can be used in your own function) and added to the return table at the bottom of the constructor. Functions of that sort can be written as follows. In this example, the data structure is called a Vector2. -- All the other functions above local function writeVector2 ( vector ) buffer . writeFloat32 ( vector . x ) buffer . writeFloat32 ( vector . y ) end local function readVector2 ( vector ) local x = buffer . readFloat32 ( vector . x ) local y = buffer . readFloat32 ( vector . y ) return x , y end return { -- All of the built-in functions writeVector2 = writeVector2 , readVector2 = readVector2 , } If that example isn't sufficient, there are several present in the Roblox version of the module.","title":"Customization"},{"location":"installation/","text":"Installing the module is rather simple. The only file that's needed for the actual BitBuffer is the main one . Copy the contents of that file to a Lua file if you're using vanilla Lua or a ModuleScript if you're using Roblox, and it's ready to go. For Roblox users \u00b6 The roblox version of the module is stored in roblox.lua . If you're using Roblox, you should probably use the files there. The Roblox version makes use of table.create and will eventually have type annotations. A few Rojo files are provided in the repository for convenience.","title":"Installation"},{"location":"installation/#for-roblox-users","text":"The roblox version of the module is stored in roblox.lua . If you're using Roblox, you should probably use the files there. The Roblox version makes use of table.create and will eventually have type annotations. A few Rojo files are provided in the repository for convenience.","title":"For Roblox users"},{"location":"reading/","text":"This example covers reading binary data with the module If you're interested in using the module to write binary data, check out the first example . The BitBuffer is also designed to easily read binary data. This is useful for all sorts of situations, but for this example the information written in the previous page will be used. To review, that data structure looked like this: local data = { name = \"John Doe\" , health = 100 , maxHealth = 100 , points = 10 , position = { x = 10.55915 , y = - 15.2222 , }, bossesKilled = { true , false , true }, } After the information was written with the BitBuffer to a file, it can be read issue with the buffer. It's as simple as reading the file contents, creating a BitBuffer with the content, and calling the respective read functions in order . If the file is read out of order, or the wrong datatypes are read, it will give unexpected results. local BitBuffer = ... -- The BitBuffer should be required here. local fileContents = ... -- The contents of the file should be put here. local data = {} local buffer = BitBuffer ( fileContents ) -- This creates a new BitBuffer with `fileContents` inside it data . name = buffer : readString () data . health = buffer : readInt16 () data . maxHealth = buffer : readInt16 () data . points = buffer : readInt16 () data . position = { x = buffer : readFloat32 (), y = buffer : readFloat32 (), } data . bossesKilled = buffer : readField ( 3 ) With minimal effort, the data is restored... For the most part. All floating point numbers are subject to minor errors, and unfortunately the BitBuffer is no different. As a result, the position data read above will not be exactly correct. This is unavoidable and cannot be fixed. If you want to minimize floating point errors, use integers, or write Float64s instead of Float32s. Technical Info \u00b6 This section analyzes the actual output of the BitBuffer and looks at what each byte is for the sake of knowledge. If viewed in a hex editor ( HxD is recommended), the above data structure looks like this when written to the file: 00 00 08 4A 6F 68 6E 20 44 6F 65 00 64 00 64 00 0A 41 28 F2 47 C1 73 8E 22 A0 As mentioned above, the data has to be read in the order it was written in. So, data.name is first. Since writeString was used to write the name, a 24-bit unsigned integer was written to indicate how long the string is, then the raw bytes of the string are written. Since the number 0x000008 is 8, the string is 8 bytes long, which means it's 4A 6F 68 6E 20 44 6F 65 or John Doe when translated to ASCII. Next, data.health . This was written as a 16-bit unsigned integer, which means that the value is 0x0064 , or 100 in decimal. This process is repeated for data.maxHealth and data.points , which are 0x0064 and 0x000A (or 100 and 10 ). Next, the position values data.position.x and data.position.y . These were written as 32-bit floating point numbers, which means that 4 bytes have to be read for each, which are 41 28 F2 47 and C1 73 8E 22 respectively. Rather than explaining floating point numbers in full here, these can be plugged into a site like float.exposed to read their values. When plugged into that site (32-bit floats are commonly called singles) 0x4128F247 is 10.5591497421264648438 and 0xC1738E22 is read as -15.2222003936767578125 . Finally, data.bossesKilled is written as a bitfield of three bools. Because individual bits can't be written to a file, the spare 5 bits are filled with 0s and written as well. The last byte in the file ( A0 ) is 10100000 in binary. Reading the first three bits of the byte gives 101 or {true, false, true} .","title":"Reading"},{"location":"reading/#technical-info","text":"This section analyzes the actual output of the BitBuffer and looks at what each byte is for the sake of knowledge. If viewed in a hex editor ( HxD is recommended), the above data structure looks like this when written to the file: 00 00 08 4A 6F 68 6E 20 44 6F 65 00 64 00 64 00 0A 41 28 F2 47 C1 73 8E 22 A0 As mentioned above, the data has to be read in the order it was written in. So, data.name is first. Since writeString was used to write the name, a 24-bit unsigned integer was written to indicate how long the string is, then the raw bytes of the string are written. Since the number 0x000008 is 8, the string is 8 bytes long, which means it's 4A 6F 68 6E 20 44 6F 65 or John Doe when translated to ASCII. Next, data.health . This was written as a 16-bit unsigned integer, which means that the value is 0x0064 , or 100 in decimal. This process is repeated for data.maxHealth and data.points , which are 0x0064 and 0x000A (or 100 and 10 ). Next, the position values data.position.x and data.position.y . These were written as 32-bit floating point numbers, which means that 4 bytes have to be read for each, which are 41 28 F2 47 and C1 73 8E 22 respectively. Rather than explaining floating point numbers in full here, these can be plugged into a site like float.exposed to read their values. When plugged into that site (32-bit floats are commonly called singles) 0x4128F247 is 10.5591497421264648438 and 0xC1738E22 is read as -15.2222003936767578125 . Finally, data.bossesKilled is written as a bitfield of three bools. Because individual bits can't be written to a file, the spare 5 bits are filled with 0s and written as well. The last byte in the file ( A0 ) is 10100000 in binary. Reading the first three bits of the byte gives 101 or {true, false, true} .","title":"Technical Info"},{"location":"writing/","text":"This example covers writing binary data with the module If you're interested in using the module to read binary data, check out the second example . The BitBuffer is designed to have both a simple and powerful API. As a rather contrived example, imagine you were developing a game and had the following data: local data = { name = \"John Doe\" , health = 100 , maxHealth = 100 , points = 10 , position = { x = 10.55915 , y = - 15.2222 , }, bossesKilled = { true , false , true }, } If you wanted to save that data normally, you might JSON it and write it to a file, which would end up looking something like this: { \"health\" : 100 , \"points\" : 10 , \"bossesKilled\" :[ true , false , true ], \"maxHealth\" : 100 , \"position\" :{ \"x\" : 10.5591500 , \"y\" : -15.2222000 }, \"name\" : \"John Doe\" } Assuming you truncate the position values like above, that's 137 bytes. Using the following code, that would be cut down to 26 bytes. local BitBuffer = ... -- The BitBuffer should be required here. local buffer = BitBuffer () buffer . writeString ( data . name ) buffer . writeUInt16 ( data . health ) -- This is assuming someone's health will get above 255 but stay below 32,767 buffer . writeUInt16 ( data . maxHealth ) buffer . writeUInt16 ( data . points ) -- Also assuming someone's points will stay rather low buffer . writeFloat32 ( data . position . x ) buffer . writeFloat32 ( data . position . y ) buffer . writeField ( table.unpack ( data . bossesKilled )) -- To do the math: 11 bytes for name (length prefix + raw bytes), 2 each for health, maxHealth, and points, -- 8 for position, and an extra 1 for bossesKilled (though you could write 5 more bools without loosing any space!). -- 11+6+8+1 = 26 local output = buffer . dumpString () -- And then write that to a file On any modern PC, a difference of 95 bytes doesn't matter too much. But if you were limited by space, it would easily be worth taking the time to write the save information like this.","title":"Writing"}]}